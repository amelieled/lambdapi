<ident> ::= ID

<path> ::= ID (DOT ID)*

<qident> ::= <path>

<term_ident> ::= AT <qident>
               | <qident>

<patt> ::= DOLLAR <ident>
         | DOLLAR WILD

<arg_ident> ::= <ident>
              | WILD

<arg> ::= <arg_ident>
        | L_PAREN <arg_ident>+ COLON <term> R_PAREN
        | L_CU_BRACKET <arg_ident>+ [COLON <term>] R_CU_BRACKET

<rw_patt_spec> ::= <term>
                 | IN <term>
                 | IN <ident> IN <term>
                 | <term> IN <term> [IN <term>]
                 | <term> AS <ident> IN <term>

<rw_patt> ::= L_SQ_BRACKET <rw_patt_spec> R_SQ_BRACKET

<tactic> ::= INTRO <arg_ident>+
           | APPLY <term>
           | SIMPL
           | REWRITE [ASSOC] [<rw_patt>] <term>
           | REFINE <term>
           | REFL
           | SYMMETRY
           | WHY3 [STRINGLIT]
           | <query>
           | FAIL

<ttactic> ::= <tactic> [SEMICOLON]

<modifier> ::= CONSTANT
             | INJECTIVE
             | PROTECTED
             | PRIVATE
             | SEQUENTIAL
             | OPAQUE

<float_of_int> ::= FLOAT
                 | INT

<config> ::= BUILTIN STRINGLIT ASSIGN <qident>
           | PREFIX <float_of_int> STRINGLIT ASSIGN <qident>
           | INFIX [ASSOC] <float_of_int> STRINGLIT ASSIGN <qident>
           | QUANTIFIER <qident>
           | UNIF_RULE <unif_rule>

<assert_not> ::= ASSERT
               | ASSERT_NOT

<query> ::= SET VERBOSE INT
          | SET FLAG STRINGLIT SWITCH
          | SET DEBUG_FLAGS
          | COMPUTE_TYPE <term>
          | COMPUTE <term>
          | SET PROVER STRINGLIT
          | SET PROVER_TIMEOUT INT
          | <assert_not> <arg>* TURNSTILE <term> COLON <term>
          | <assert_not> <arg>* TURNSTILE <term> EQUIV <term>
          | PRINT [<qident>]
          | PROOFTERM

<proof_end> ::= END
              | ADMIT
              | ABORT

<proof> ::= BEGIN <ttactic>* <proof_end>

<inductive> ::= <ident> COLON <term> ASSIGN [VBAR] [<ident> COLON <term>
                (VBAR <ident> COLON <term>)*]

<command> ::= REQUIRE OPEN <path>+ SEMICOLON
            | REQUIRE <path>+ SEMICOLON
            | REQUIRE <path> AS <ident> SEMICOLON
            | OPEN <path> SEMICOLON
            | <modifier>* SYMBOL <ident> <arg>* COLON <term> SEMICOLON
            | <modifier>* SYMBOL <ident> <arg>* [COLON <term>] <proof>
            | <modifier>* SYMBOL <ident> <arg>* [COLON <term>] ASSIGN
              [<term>] SEMICOLON
            | <modifier>* SYMBOL <ident> <arg>* [COLON <term>] ASSIGN
              [<term>] <proof>
            | <modifier>* INDUCTIVE <inductive> (WITH <inductive>)* SEMICOLON
            | RULE <rule> (WITH <rule>)* SEMICOLON
            | SET <config> SEMICOLON
            | <query> SEMICOLON
            | EOF

<env> ::= L_SQ_BRACKET [<term> (SEMICOLON <term>)*] R_SQ_BRACKET

<sterm> ::= AT <qident>
          | <qident>
          | WILD
          | TYPE
          | QUESTION_MARK <ident> [<env>]
          | <patt> [<env>]
          | L_PAREN <term> R_PAREN
          | L_CU_BRACKET <term> R_CU_BRACKET
          | INT

<aterm> ::= <sterm>+

<term> ::= <aterm>
         | <term> ARROW <term>
         | BACKQUOTE <term_ident> <binder>
         | PI <binder>
         | LAMBDA <binder>
         | LET <ident> <arg>* [COLON <term>] ASSIGN <term> IN <term>

<binder> ::= <arg>+ COMMA <term>
           | <arg_ident> COLON <term> COMMA <term>

<rule> ::= <term> REWRITE <term>

<unification> ::= <term> EQUIV <term>

<unif_rule> ::= <unification> REWRITE BEGIN <unification> (SEMICOLON
                <unification>)* END


